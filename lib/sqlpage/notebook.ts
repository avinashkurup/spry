import { ensureDir } from "jsr:@std/fs@^1";
import { dirname, join } from "jsr:@std/path@^1";
import { z } from "jsr:@zod/zod@4";
import { safeSourceText } from "../universal/content-acquisition.ts";
import { notebooks } from "../universal/md-notebook.ts";
import {
  mutatePlaybookCodeCells,
  pipedPlaybookCodeCellMutators,
  PlaybookCodeCell,
  PlaybookCodeCellMutator,
  playbooks,
  safeFrontmatter,
} from "../universal/md-playbook.ts";
import { forestToStatelessViews } from "../universal/path-tree-tabular.ts";
import { sqlPageConfSchema } from "./conf.ts";
import {
  enrichInfoDirective,
  InfoDirectiveCells,
  Layouts,
} from "./directives.ts";
import { enrichRoute, isRouteSupplier, PageRoute, Routes } from "./route.ts";

// deno-lint-ignore no-explicit-any
type Any = any;

export enum SourceRelativeTo {
  LocalFs = "fs",
  Module = "module",
}

const defaultFmSchema = z.object({
  siteName: z.string().optional(),
  "sqlpage-conf": sqlPageConfSchema.optional(),
}).catchall(z.unknown());

export type SqlPageFile = {
  readonly kind: "head_sql" | "tail_sql" | "sqlpage_file_upsert";
  readonly path: string; // relative path (e.g., "sql.d/head/001.sql", "admin/index.sql")
  contents: string; // file contents
  readonly lastModified?: Date; // optional timestamp (not used in DML; engine time is used)
  readonly cell?: PlaybookCodeCell<string>;
  readonly asErrorContents: (text: string, error: unknown) => string;
  readonly isAutoGenerated?: boolean;
  readonly isUnsafeInterpolatable?: boolean;
  readonly isLayoutCandidate?: boolean;
  error?: unknown;
  isInterpolated?: boolean;
  layout?: Awaited<ReturnType<Layouts["findLayout"]>>;
};

export const enrichFrontmatter: PlaybookCodeCellMutator<string> = (
  cell,
  { pb },
) => {
  if ("frontmatter" in cell) return;
  (cell as Any).frontmatter = pb.notebook.fm;
};

export class SqlPageNotebook {
  protected readonly PlaybookCodeCellMutators: PlaybookCodeCellMutator<
    string
  >[] = [];
  protected pipedDocCCMutators = pipedPlaybookCodeCellMutators(
    this.PlaybookCodeCellMutators,
  );
  protected constructor() {
    this.setupPlaybookCodeCellMutators();
  }

  withPlaybookCodeCellMutator(dcce: PlaybookCodeCellMutator<string>) {
    this.PlaybookCodeCellMutators.push(dcce);
    this.pipedDocCCMutators = pipedPlaybookCodeCellMutators(
      this.PlaybookCodeCellMutators,
    );
  }

  setupPlaybookCodeCellMutators() {
    // the order of these mutators matter!
    this.withPlaybookCodeCellMutator(enrichInfoDirective);
    this.withPlaybookCodeCellMutator(enrichRoute);
    this.withPlaybookCodeCellMutator(enrichFrontmatter);
  }

  async *notebooks(opts: { md: string[]; srcRelTo: SourceRelativeTo }) {
    const sources = async function* () {
      for await (const md of opts.md) {
        const safeMdSrc = await safeSourceText(md, opts.srcRelTo);
        if (safeMdSrc.nature == "error") {
          console.error(safeMdSrc);
          continue;
        }
        yield {
          provenance: typeof safeMdSrc.source === "string"
            ? safeMdSrc.source
            : safeMdSrc.source.href,
          content: safeMdSrc.text,
        };
      }
    };
    for await (
      const safeNB of safeFrontmatter(defaultFmSchema, notebooks(sources()))
    ) {
      if (safeNB.zodParseResult.success) {
        yield safeNB.notebook;
      } else {
        console.error(safeNB.notebook.provenance);
        console.error(z.prettifyError(safeNB.zodParseResult.error));
      }
    }
  }

  async *sqlPageCodebooks(opts: { md: string[]; srcRelTo: SourceRelativeTo }) {
    return yield* mutatePlaybookCodeCells(
      this.pipedDocCCMutators,
      playbooks(this.notebooks(opts), { kind: "hr" }),
    );
  }

  async *codeCells(
    opts: { md: string[]; srcRelTo: SourceRelativeTo },
    directives: InfoDirectiveCells,
  ) {
    const spBooks = await Array.fromAsync(this.sqlPageCodebooks(opts));
    const EXTRACTED = ".extractedInCodeCells" as const;
    for await (const spnb of spBooks) {
      for (const cell of spnb.cells) {
        if (cell.kind === "code") {
          if (directives.register(cell)) {
            (cell as Any)[EXTRACTED] = true;
          }
        }
      }
    }

    for await (const spnb of spBooks) {
      for (const cell of spnb.cells) {
        if (cell.kind === "code" && !(EXTRACTED in cell)) {
          yield cell;
        }
      }

      const { notebook: nb } = spnb;
      if (nb.issues.length) {
        yield {
          kind: "code",
          language: "json",
          source: JSON.stringify(nb.issues, null, 2),
          info: "NOTEBOOK_ISSUES",
          attrs: { issues: nb.issues },
          provenance: nb.provenance,
        } satisfies PlaybookCodeCell<string>;
      }
    }
  }

  async *rawSqlPageFileEntries(
    opts: { md: string[]; srcRelTo: SourceRelativeTo },
    directives: InfoDirectiveCells,
  ): AsyncGenerator<SqlPageFile> {
    const pageRoutes: PageRoute[] = [];

    const sqlSPF = (
      path: string,
      contents: string,
      candidate?: Partial<SqlPageFile>,
    ): SqlPageFile => ({
      kind: candidate?.kind ?? "sqlpage_file_upsert",
      path,
      contents,
      asErrorContents: (text) => text.replaceAll(/^/gm, "-- "),
      ...candidate,
    });

    const jsonSPF = (
      path: string,
      contents: string,
      candidate?: Partial<SqlPageFile>,
    ): SqlPageFile => ({
      kind: candidate?.kind ?? "sqlpage_file_upsert",
      path,
      contents,
      asErrorContents: (text, error) => JSON.stringify({ text, error }),
      ...candidate,
    });

    function counter<Identifier>(identifier: Identifier, padValue = 4) {
      let value = -1;
      const incr = () => ++value;
      const next = () => String(incr()).padStart(padValue, "0");
      return { identifier, incr, next };
    }

    const codeCells = await Array.fromAsync(
      this.codeCells(opts, directives),
    );

    const headCount = counter("head");
    for (const head of directives.heads) {
      yield sqlSPF(`sql.d/head/${headCount.next()}.sql`, head.source, {
        kind: "head_sql",
        cell: head,
      });
    }

    for await (const cell of codeCells) {
      switch (cell.language) {
        case "json": {
          if (cell.info && cell.info === "NOTEBOOK_ISSUES") {
            yield jsonSPF(
              `spry.d/issues/${cell.provenance}.auto.json`,
              cell.source,
              { cell, isAutoGenerated: true },
            );
          }
          break;
        }
        case "sql": {
          if (!cell.info) {
            console.warn(
              `sql fenced block found without INFO on line ${cell.startLine} of ${cell.provenance}`,
            );
            continue;
          }

          const { info: path } = cell;
          yield sqlSPF(path, cell.source, {
            cell,
            isUnsafeInterpolatable: true,
            isLayoutCandidate: true,
          });

          if (Object.entries(cell.attrs).length) {
            if (isRouteSupplier(cell.attrs)) {
              pageRoutes.push(cell.attrs.route as PageRoute);
            }
            yield jsonSPF(
              `spry.d/auto/resource/${path}.auto.json`,
              JSON.stringify(this.dropUndef(cell.attrs), null, 2),
              { cell, isAutoGenerated: true },
            );
          }
          break;
        }
      }
    }

    const layoutCount = counter("layout");
    for (const lo of directives.layouts.layouts) {
      yield sqlSPF(
        `spry.d/auto/layout/${layoutCount.next()}.auto.sql`,
        `-- ${JSON.stringify(lo.infoDirective)}\n${lo.source}`,
        { cell: lo, isAutoGenerated: true },
      );
    }

    const tailCount = counter("tail");
    for (const tail of directives.tails) {
      yield sqlSPF(`sql.d/tail/${tailCount.next()}.sql`, tail.source, {
        kind: "tail_sql",
        cell: tail,
      });
    }

    const routes = new Routes(pageRoutes);
    const { forest, breadcrumbs, edges, serializers } = await routes.populate();

    yield sqlSPF(
      `spry.d/auto/route/tree.auto.txt`,
      serializers.asciiTreeText({
        showPath: true,
        includeCounts: true,
      }),
      { isAutoGenerated: true },
    );
    yield jsonSPF(
      `spry.d/auto/route/forest.auto.json`,
      JSON.stringify(forest.roots, null, 2),
      { isAutoGenerated: true },
    );
    yield jsonSPF(
      `spry.d/auto/route/forest.schema.auto.json`,
      JSON.stringify(z.toJSONSchema(forest.schemas.forest), null, 2),
      { isAutoGenerated: true },
    );
    yield jsonSPF(
      `spry.d/auto/route/breadcrumbs.auto.json`,
      JSON.stringify(breadcrumbs.crumbs, null, 2),
      { isAutoGenerated: true },
    );
    yield jsonSPF(
      `spry.d/auto/route/breadcrumbs.schema.auto.json`,
      JSON.stringify(z.toJSONSchema(breadcrumbs.schema), null, 2),
      { isAutoGenerated: true },
    );
    yield jsonSPF(
      `spry.d/auto/route/edges.auto.json`,
      JSON.stringify(edges.edges, null, 2),
      { isAutoGenerated: true },
    );
    yield jsonSPF(
      `spry.d/auto/route/edges.schema.auto.json`,
      JSON.stringify(z.toJSONSchema(edges.schemas.edges), null, 2),
      { isAutoGenerated: true },
    );

    const sv = forestToStatelessViews(forest, { viewPrefix: "navigation_" });
    yield sqlSPF(`sql.d/tail/navigation.auto.sql`, sv.sql, {
      kind: "tail_sql",
    });
  }

  interpolationCtx(_opts: { md: string[] }, directives: InfoDirectiveCells) {
    return {
      sitePrefixed: (sqlClause: string) =>
        `(sqlpage.environment_variable('SQLPAGE_SITE_PREFIX') || ${sqlClause})`,
      partial: (name: string) =>
        directives.partials.find((p) => p.infoDirective.identity == name)
          ?.source ?? `/* partial '${name}' not found in directives */`,
    };
  }

  async *finalSqlPageFileEntries(
    opts: { md: string[]; srcRelTo: SourceRelativeTo },
  ) {
    const directives = new InfoDirectiveCells();
    const baseCtx = this.interpolationCtx(opts, directives);

    for await (const spf of this.rawSqlPageFileEntries(opts, directives)) {
      const { path } = spf;

      // ctx is for interpolation so it won't be used locally but in the interpolation (maybe)
      const ctx = { ...spf, ...spf.cell?.attrs, ...baseCtx };
      try {
        const layout = spf.isLayoutCandidate
          ? directives.layouts.findLayout(path)
          : undefined;

        if (spf.isUnsafeInterpolatable) {
          const source = layout ? layout.wrap(spf.contents) : spf.contents;

          // Escape backticks and backslashes so we can embed `source` inside a template literal
          const safe = source.replace(/\\/g, "\\\\").replace(/`/g, "\\`");

          // Direct eval runs in the current scope (locals in this block) and we .call(this)
          // so `${this.*}` inside the template works too.
          // NOTE: This is intentionally unsafe. Do not feed untrusted content.
          const mutated = eval(
            `(function() { return \`${safe}\`; }).call(this)`,
          );

          if (mutated !== spf.contents) {
            spf.contents = String(mutated);
            spf.isInterpolated = true;
          }
        } else if (layout) {
          spf.contents = layout.wrap(spf.contents);
        }

        if (layout) spf.layout = layout;
        yield spf;
      } catch (error) {
        spf.error = error;
        yield {
          ...spf,
          contents: spf.asErrorContents(
            `finalSqlPageFileEntries error: ${String(error)}\n*****\n${
              JSON.stringify({ ctx, spf }, null, 2)
            }`,
            error,
          ),
        };
      }
    }
  }

  async materializeContent(
    opts: { fs: string; path: string; contents: string },
  ) {
    const { fs, path, contents } = opts;
    const absPath = join(fs, path);
    await ensureDir(dirname(absPath));
    await Deno.writeTextFile(absPath, contents);
    return absPath;
  }

  async *materializeFs(
    opts: { md: string[]; srcRelTo: SourceRelativeTo; fs: string },
  ) {
    for await (const spf of this.finalSqlPageFileEntries(opts)) {
      const absPath = this.materializeContent({
        fs: opts.fs,
        path: spf.path,
        contents: spf.contents,
      });
      yield { ...spf, absPath };
    }
  }

  /**
   * Build DML statements to upsert files into a SQLPage virtual-files table.
   * dialect "sqlite":
   *   INSERT INTO sqlpage_files (path, contents, last_modified) VALUES ('…','…', CURRENT_TIMESTAMP)
   *   ON CONFLICT(path) DO UPDATE
   *     SET contents = excluded.contents,
   *         last_modified = CURRENT_TIMESTAMP
   *     WHERE sqlpage_files.contents <> excluded.contents;
   *
   * Returns one object per file, tagged with kind: "sqlpage_file_insert".
   * On conflict when contents differ, last_modified is set by the SQL engine (CURRENT_TIMESTAMP).
   * If contents are identical, the row is left unchanged.
   */
  async sqlPageFilesUpsertDML(
    dialect: "sqlite",
    opts: {
      md: string[];
      srcRelTo: SourceRelativeTo;
      includeSqlPageFilesTable?: boolean;
    },
  ) {
    if (dialect !== "sqlite") {
      throw new Error(`Unsupported dialect: ${dialect}`);
    }
    if (opts.includeSqlPageFilesTable) {
      `CREATE TABLE IF NOT EXISTS "sqlpage_files" ("path" VARCHAR PRIMARY KEY NOT NULL, "contents" TEXT NOT NULL, "last_modified" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP);`;
    }

    const esc = (s: string) => s.replace(/'/g, "''");
    const list = await Array.fromAsync(this.finalSqlPageFileEntries(opts));

    // Deterministic order: heads → non-head/tail → tails
    return [
      opts.includeSqlPageFilesTable
        ? `CREATE TABLE IF NOT EXISTS "sqlpage_files" ("path" VARCHAR PRIMARY KEY NOT NULL, "contents" TEXT NOT NULL, "last_modified" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP);`
        : "-- sqlpage_files DDL not requested",
      ...list.filter((e) => e.kind === "head_sql").map((spf) => spf.contents),
      ...list.filter((e) => e.kind === "sqlpage_file_upsert").map((f) => {
        const pathLit = `'${esc(f.path)}'`;
        const bodyLit = `'${esc(f.contents)}'`;
        return `INSERT INTO sqlpage_files (path, contents, last_modified) VALUES (${pathLit}, ${bodyLit}, CURRENT_TIMESTAMP) ` +
          `ON CONFLICT(path) DO UPDATE SET contents = excluded.contents, last_modified = CURRENT_TIMESTAMP ` +
          `WHERE sqlpage_files.contents <> excluded.contents;`;
      }), // pages, shells, partials, etc.
      ...list.filter((e) => e.kind === "tail_sql").map((spf) => spf.contents),
    ];
  }

  // Utility: drop undefined recursively
  protected dropUndef<T extends Record<string, unknown>>(obj: T): T {
    const out: Record<string, unknown> = {};
    for (const [k, v] of Object.entries(obj)) {
      if (v === undefined) continue;
      if (v && typeof v === "object" && !Array.isArray(v)) {
        const nested = this.dropUndef(v as Record<string, unknown>);
        if (Object.keys(nested).length > 0) out[k] = nested;
      } else {
        out[k] = v;
      }
    }
    return out as T;
  }

  // Produces the exact JSON object you can write to sqlpage/sqlpage.json
  sqlPageConf(conf: z.infer<typeof sqlPageConfSchema>) {
    // Start from a shallow clone
    const out: Record<string, unknown> = { ...conf };

    // Flatten nested OIDC if provided
    if (conf.oidc) {
      const { issuer_url, client_id, client_secret, scopes, redirect_path } =
        conf.oidc;
      // Only set flat keys if not already set at top level
      if (issuer_url && out.oidc_issuer_url === undefined) {
        out.oidc_issuer_url = issuer_url;
      }
      if (client_id && out.oidc_client_id === undefined) {
        out.oidc_client_id = client_id;
      }
      if (client_secret && out.oidc_client_secret === undefined) {
        out.oidc_client_secret = client_secret;
      }
      if (scopes !== undefined) out.oidc_scopes = scopes; // SQLPage ignores unknowns; keeping for future
      if (redirect_path !== undefined) out.oidc_redirect_path = redirect_path;
      delete out.oidc;
    }

    // Clean undefineds
    return this.dropUndef(out);
  }

  static instance() {
    return new SqlPageNotebook();
  }
}
