import { ensureDir } from "jsr:@std/fs@^1";
import { dirname, join } from "jsr:@std/path@^1";
import { z } from "jsr:@zod/zod@4";
import {
  DocCodeCellMutator,
  DocumentedCodeCell,
  documentedNotebooks,
  mutateDocCodeCells,
  notebooks,
  pipedDocCodeCellMutators,
  safeFrontmatter,
} from "../notebook/mod.ts";
import { sqlPageConfSchema } from "./conf.ts";
import {
  enrichInfoDirective,
  InfoDirectiveCells,
  Layouts,
} from "./directives.ts";
import { enrichRoute, isRouteSupplier, PageRoute, Routes } from "./route.ts";

// deno-lint-ignore no-explicit-any
type Any = any;

const defaultFmSchema = z.object({
  siteName: z.string().optional(),
  "sqlpage-conf": sqlPageConfSchema.optional(),
}).catchall(z.unknown());

export type SqlPageFile = {
  readonly kind: "head_sql" | "tail_sql" | "sqlpage_file_upsert";
  readonly path: string; // relative path (e.g., "sql.d/head/001.sql", "admin/index.sql")
  contents: string; // file contents
  readonly lastModified?: Date; // optional timestamp (not used in DML; engine time is used)
  readonly cell?: DocumentedCodeCell<string>;
  readonly asErrorContents: (text: string, error: unknown) => string;
  readonly isAutoGenerated?: boolean;
  readonly isUnsafeInterpolatable?: boolean;
  readonly isLayoutCandidate?: boolean;
  isInterpolated?: boolean;
  layout?: Awaited<ReturnType<Layouts["findLayout"]>>;
};

export const enrichFrontmatter: DocCodeCellMutator<string> = (cell, { nb }) => {
  if ("frontmatter" in cell) return;
  (cell as Any).frontmatter = nb.notebook.fm;
};

export class SqlPageNotebook {
  protected readonly docCodeCellMutators: DocCodeCellMutator<string>[] = [];
  protected pipedDocCCMutators = pipedDocCodeCellMutators(
    this.docCodeCellMutators,
  );
  protected constructor() {
    this.setupDocCodeCellMutators();
  }

  withDocCodeCellMutator(dcce: DocCodeCellMutator<string>) {
    this.docCodeCellMutators.push(dcce);
    this.pipedDocCCMutators = pipedDocCodeCellMutators(
      this.docCodeCellMutators,
    );
  }

  setupDocCodeCellMutators() {
    // the order of these mutators matter!
    this.withDocCodeCellMutator(enrichInfoDirective);
    this.withDocCodeCellMutator(enrichRoute);
    this.withDocCodeCellMutator(enrichFrontmatter);
  }

  async *notebooks(opts: { md: string[] }) {
    const sources = async function* () {
      for await (const md of opts.md) {
        yield {
          provenance: md,
          content: await Deno.readTextFile(md),
        };
      }
    };
    for await (
      const safeNB of safeFrontmatter(defaultFmSchema, notebooks(sources()))
    ) {
      if (safeNB.zodParseResult.success) {
        yield safeNB.notebook;
      } else {
        console.error(safeNB.notebook.provenance);
        console.error(z.prettifyError(safeNB.zodParseResult.error));
      }
    }
  }

  async *sqlPageCodebooks(opts: { md: string[] }) {
    return yield* mutateDocCodeCells(
      this.pipedDocCCMutators,
      documentedNotebooks(this.notebooks(opts), { kind: "hr" }),
    );
  }

  async *codeCells(
    opts: { md: string[] },
    directives: InfoDirectiveCells,
  ) {
    const spBooks = await Array.fromAsync(this.sqlPageCodebooks(opts));
    const EXTRACTED = ".extractedInCodeCells" as const;
    for await (const spnb of spBooks) {
      for (const cell of spnb.cells) {
        if (cell.kind === "code") {
          if (directives.register(cell)) {
            (cell as Any)[EXTRACTED] = true;
          }
        }
      }
    }

    for await (const spnb of spBooks) {
      for (const cell of spnb.cells) {
        if (cell.kind === "code" && !(EXTRACTED in cell)) {
          yield cell;
        }
      }

      const { notebook: nb } = spnb;
      if (nb.issues.length) {
        yield {
          kind: "code",
          language: "json",
          source: JSON.stringify(nb.issues, null, 2),
          info: "NOTEBOOK_ISSUES",
          attrs: { issues: nb.issues },
          provenance: nb.provenance,
        } satisfies DocumentedCodeCell<string>;
      }
    }
  }

  async *rawSqlPageFileEntries(
    opts: { md: string[] },
    directives: InfoDirectiveCells,
  ): AsyncGenerator<SqlPageFile> {
    const pageRoutes: PageRoute[] = [];
    const errorAsSqlComments = (text: string, _error: unknown) =>
      text.replaceAll(/^/gm, "-- ");
    const errorAsJSON = (text: string, error: unknown) =>
      JSON.stringify({ text, error });

    function counter<Identifier>(identifier: Identifier, padValue = 4) {
      let value = -1;
      const incr = () => ++value;
      const next = () => String(incr()).padStart(padValue, "0");
      return { identifier, incr, next };
    }

    const codeCells = await Array.fromAsync(
      this.codeCells(opts, directives),
    );

    const headCount = counter("head");
    for (const head of directives.heads) {
      yield {
        path: `sql.d/head/${headCount.next()}.sql`,
        kind: "head_sql",
        contents: head.source,
        cell: head,
        asErrorContents: errorAsSqlComments,
      } satisfies SqlPageFile;
    }

    for await (const cc of codeCells) {
      switch (cc.language) {
        case "json": {
          if (cc.info && cc.info === "NOTEBOOK_ISSUES") {
            yield {
              path: `spry.d/issues/${cc.provenance}.auto.json`,
              kind: "sqlpage_file_upsert",
              contents: cc.source,
              cell: cc,
              asErrorContents: errorAsJSON,
              isAutoGenerated: true,
            } satisfies SqlPageFile;
          }
          break;
        }
        case "sql": {
          if (!cc.info) {
            console.warn(
              `sql fenced block found without INFO on line ${cc.startLine} of ${cc.provenance}`,
            );
            continue;
          }
          const { info: path } = cc;
          yield {
            path,
            kind: "sqlpage_file_upsert",
            contents: cc.source,
            cell: cc,
            asErrorContents: errorAsSqlComments,
            isUnsafeInterpolatable: true,
            isLayoutCandidate: true,
          } satisfies SqlPageFile;
          if (Object.entries(cc.attrs).length) {
            if (isRouteSupplier(cc.attrs)) {
              pageRoutes.push(cc.attrs.route as PageRoute);
            }
            yield {
              path: `spry.d/auto/resource/${path}.auto.json`,
              kind: "sqlpage_file_upsert",
              contents: JSON.stringify(this.dropUndef(cc.attrs), null, 2),
              cell: cc,
              asErrorContents: errorAsJSON,
              isAutoGenerated: true,
            } satisfies SqlPageFile;
          }
          break;
        }
      }
    }

    const layoutCount = counter("layout");
    for (const lo of directives.layouts.layouts) {
      yield {
        path: `spry.d/auto/layout/${layoutCount.next()}.auto.sql`,
        kind: "sqlpage_file_upsert",
        contents: `-- ${JSON.stringify(lo.infoDirective)}\n${lo.source}`,
        cell: lo,
        asErrorContents: errorAsSqlComments,
        isAutoGenerated: true,
      } satisfies SqlPageFile;
    }

    const tailCount = counter("tail");
    for (const tail of directives.tails) {
      yield {
        path: `sql.d/tail/${tailCount.next()}.sql`,
        kind: "tail_sql",
        contents: tail.source,
        cell: tail,
        asErrorContents: errorAsSqlComments,
      } satisfies SqlPageFile;
    }

    const routes = new Routes(pageRoutes);
    const { forest, breadcrumbs, edges, serializers } = await routes.populate();
    yield {
      path: "spry.d/auto/route/tree.auto.txt",
      contents: serializers.asciiTreeText({
        showPath: true,
        includeCounts: true,
      }),
      kind: "sqlpage_file_upsert",
      asErrorContents: errorAsSqlComments,
      isAutoGenerated: true,
    } satisfies SqlPageFile;
    yield {
      path: "spry.d/auto/route/forest.auto.json",
      contents: JSON.stringify(forest, null, 2),
      kind: "sqlpage_file_upsert",
      asErrorContents: errorAsJSON,
      isAutoGenerated: true,
    } satisfies SqlPageFile;
    yield {
      path: "spry.d/auto/route/breadcrumbs.auto.json",
      contents: JSON.stringify(breadcrumbs, null, 2),
      kind: "sqlpage_file_upsert",
      asErrorContents: errorAsJSON,
      isAutoGenerated: true,
    } satisfies SqlPageFile;
    yield {
      path: "spry.d/auto/route/edges.auto.json",
      contents: JSON.stringify(edges, null, 2),
      kind: "sqlpage_file_upsert",
      asErrorContents: errorAsJSON,
      isAutoGenerated: true,
    } satisfies SqlPageFile;
  }

  async *finalSqlPageFileEntries(opts: { md: string[] }) {
    const directives = new InfoDirectiveCells();
    const baseCtx = {
      sitePrefixed: (sqlClause: string) =>
        `(sqlpage.environment_variable('SQLPAGE_SITE_PREFIX') || ${sqlClause})`,
      partial: (name: string) =>
        directives.partials.find((p) => p.infoDirective.identity == name)
          ?.source ?? `/* partial '${name}' not found in directives */`,
    };

    for await (const spf of this.rawSqlPageFileEntries(opts, directives)) {
      const { path } = spf;

      // ctx is for interpolation so it won't be used locally but in the interpolation (maybe)
      const ctx = { ...spf, ...spf.cell?.attrs, ...baseCtx };
      try {
        const layout = spf.isLayoutCandidate
          ? directives.layouts.findLayout(path)
          : undefined;

        if (spf.isUnsafeInterpolatable) {
          const source = layout ? layout.wrap(spf.contents) : spf.contents;

          // Escape backticks and backslashes so we can embed `source` inside a template literal
          const safe = source.replace(/\\/g, "\\\\").replace(/`/g, "\\`");

          // Direct eval runs in the current scope (locals in this block) and we .call(this)
          // so `${this.*}` inside the template works too.
          // NOTE: This is intentionally unsafe. Do not feed untrusted content.
          const mutated = eval(
            `(function() { return \`${safe}\`; }).call(this)`,
          );

          if (mutated !== spf.contents) {
            spf.contents = String(mutated);
            spf.isInterpolated = true;
          }
        } else if (layout) {
          spf.contents = layout.wrap(spf.contents);
        }

        if (layout) spf.layout = layout;
        yield spf;
      } catch (error) {
        (spf as Any).isSqlPageFileError = error;
        yield {
          ...spf,
          contents: spf.asErrorContents(
            `finalSqlPageFileEntries error: ${String(error)}\n*****\n${
              JSON.stringify({ ctx, spf }, null, 2)
            }`,
            error,
          ),
        };
      }
    }
  }

  async materializeContent(
    opts: { fs: string; path: string; contents: string },
  ) {
    const { fs, path, contents } = opts;
    const absPath = join(fs, path);
    await ensureDir(dirname(absPath));
    await Deno.writeTextFile(absPath, contents);
    return absPath;
  }

  async *materializeFs(opts: { md: string[]; fs: string }) {
    for await (const spf of this.finalSqlPageFileEntries(opts)) {
      const absPath = this.materializeContent({
        fs: opts.fs,
        path: spf.path,
        contents: spf.contents,
      });
      yield { ...spf, absPath };
    }
  }

  /**
   * Build DML statements to upsert files into a SQLPage virtual-files table.
   * dialect "sqlite":
   *   INSERT INTO sqlpage_files (path, contents, last_modified) VALUES ('…','…', CURRENT_TIMESTAMP)
   *   ON CONFLICT(path) DO UPDATE
   *     SET contents = excluded.contents,
   *         last_modified = CURRENT_TIMESTAMP
   *     WHERE sqlpage_files.contents <> excluded.contents;
   *
   * Returns one object per file, tagged with kind: "sqlpage_file_insert".
   * On conflict when contents differ, last_modified is set by the SQL engine (CURRENT_TIMESTAMP).
   * If contents are identical, the row is left unchanged.
   */
  async sqlPageFilesUpsertDML(
    dialect: "sqlite",
    opts: { md: string[]; includeSqlPageFilesTable?: boolean },
  ) {
    if (dialect !== "sqlite") {
      throw new Error(`Unsupported dialect: ${dialect}`);
    }
    if (opts.includeSqlPageFilesTable) {
      `CREATE TABLE IF NOT EXISTS "sqlpage_files" ("path" VARCHAR PRIMARY KEY NOT NULL, "contents" TEXT NOT NULL, "last_modified" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP);`;
    }

    const esc = (s: string) => s.replace(/'/g, "''");
    const list = await Array.fromAsync(this.finalSqlPageFileEntries(opts));

    // Deterministic order: heads → non-head/tail → tails
    return [
      opts.includeSqlPageFilesTable
        ? `CREATE TABLE IF NOT EXISTS "sqlpage_files" ("path" VARCHAR PRIMARY KEY NOT NULL, "contents" TEXT NOT NULL, "last_modified" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP);`
        : "-- sqlpage_files DDL not requested",
      ...list.filter((e) => e.kind === "head_sql").map((spf) => spf.contents),
      ...list.filter((e) => e.kind === "sqlpage_file_upsert").map((f) => {
        const pathLit = `'${esc(f.path)}'`;
        const bodyLit = `'${esc(f.contents)}'`;
        return `INSERT INTO sqlpage_files (path, contents, last_modified) VALUES (${pathLit}, ${bodyLit}, CURRENT_TIMESTAMP) ` +
          `ON CONFLICT(path) DO UPDATE SET contents = excluded.contents, last_modified = CURRENT_TIMESTAMP ` +
          `WHERE sqlpage_files.contents <> excluded.contents;`;
      }), // pages, shells, partials, etc.
      ...list.filter((e) => e.kind === "tail_sql").map((spf) => spf.contents),
    ];
  }

  // Utility: drop undefined recursively
  protected dropUndef<T extends Record<string, unknown>>(obj: T): T {
    const out: Record<string, unknown> = {};
    for (const [k, v] of Object.entries(obj)) {
      if (v === undefined) continue;
      if (v && typeof v === "object" && !Array.isArray(v)) {
        const nested = this.dropUndef(v as Record<string, unknown>);
        if (Object.keys(nested).length > 0) out[k] = nested;
      } else {
        out[k] = v;
      }
    }
    return out as T;
  }

  // Produces the exact JSON object you can write to sqlpage/sqlpage.json
  sqlPageConf(conf: z.infer<typeof sqlPageConfSchema>) {
    // Start from a shallow clone
    const out: Record<string, unknown> = { ...conf };

    // Flatten nested OIDC if provided
    if (conf.oidc) {
      const { issuer_url, client_id, client_secret, scopes, redirect_path } =
        conf.oidc;
      // Only set flat keys if not already set at top level
      if (issuer_url && out.oidc_issuer_url === undefined) {
        out.oidc_issuer_url = issuer_url;
      }
      if (client_id && out.oidc_client_id === undefined) {
        out.oidc_client_id = client_id;
      }
      if (client_secret && out.oidc_client_secret === undefined) {
        out.oidc_client_secret = client_secret;
      }
      if (scopes !== undefined) out.oidc_scopes = scopes; // SQLPage ignores unknowns; keeping for future
      if (redirect_path !== undefined) out.oidc_redirect_path = redirect_path;
      delete out.oidc;
    }

    // Clean undefineds
    return this.dropUndef(out);
  }

  static instance() {
    return new SqlPageNotebook();
  }
}
